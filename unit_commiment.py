import pyomo.environ as pyo

# --- Model Data ---
# Number of time periods
T = 24 # e.g., 24 hours

# Generator Data
# For simplicity, using lists of dicts. In a larger setup, pandas DataFrames are good.
generators_data = [
    {
        "id": "G1", "Pmin": 50, "Pmax": 200, "Cost_Startup": 500, "Cost_NoLoad": 20, "Cost_Gen": 10,
        "MinUpTime": 3, "MinDownTime": 2, "Initial_Status": 0, "Initial_Time_On": 0, "Initial_Time_Off": 5
    },
    {
        "id": "G2", "Pmin": 80, "Pmax": 300, "Cost_Startup": 800, "Cost_NoLoad": 30, "Cost_Gen": 15,
        "MinUpTime": 4, "MinDownTime": 3, "Initial_Status": 1, "Initial_Time_On": 10, "Initial_Time_Off": 0
    },
    {
        "id": "G3", "Pmin": 20, "Pmax": 100, "Cost_Startup": 200, "Cost_NoLoad": 10, "Cost_Gen": 25, # Peaker
        "MinUpTime": 1, "MinDownTime": 1, "Initial_Status": 0, "Initial_Time_On": 0, "Initial_Time_Off": 2
    }
]

# System Demand (MW) for T periods
# Example: A simple daily load curve
demand_data = [
    100, 110, 105, 100, 120, 150, 180, 220, 250, 260, 270, 280,
    275, 260, 240, 220, 200, 180, 160, 150, 140, 130, 120, 110
]
if len(demand_data) != T:
    raise ValueError(f"Demand data length ({len(demand_data)}) must match T ({T})")

# --- Pyomo Model ---
model = pyo.ConcreteModel(name="UnitCommitment_Gurobi") # Changed name slightly for clarity

# --- Sets ---
model.I_set = pyo.Set(initialize=[gen['id'] for gen in generators_data])
model.T_set = pyo.RangeSet(1, T) # 1-based indexing for time periods

# --- Parameters ---
# Generator parameters
model.Pmin = pyo.Param(model.I_set, initialize={gen['id']: gen['Pmin'] for gen in generators_data})
model.Pmax = pyo.Param(model.I_set, initialize={gen['id']: gen['Pmax'] for gen in generators_data})
model.Cost_Startup = pyo.Param(model.I_set, initialize={gen['id']: gen['Cost_Startup'] for gen in generators_data})
model.Cost_NoLoad = pyo.Param(model.I_set, initialize={gen['id']: gen['Cost_NoLoad'] for gen in generators_data})
model.Cost_Gen = pyo.Param(model.I_set, initialize={gen['id']: gen['Cost_Gen'] for gen in generators_data})
model.MinUpTime = pyo.Param(model.I_set, initialize={gen['id']: gen['MinUpTime'] for gen in generators_data})
model.MinDownTime = pyo.Param(model.I_set, initialize={gen['id']: gen['MinDownTime'] for gen in generators_data})
model.Initial_Status = pyo.Param(model.I_set, initialize={gen['id']: gen['Initial_Status'] for gen in generators_data})
model.Initial_Time_On = pyo.Param(model.I_set, initialize={gen['id']: gen['Initial_Time_On'] for gen in generators_data})
model.Initial_Time_Off = pyo.Param(model.I_set, initialize={gen['id']: gen['Initial_Time_Off'] for gen in generators_data})

# Demand parameter
model.Demand = pyo.Param(model.T_set, initialize={t: demand_data[t-1] for t in model.T_set}) # t-1 due to 0-indexed list

# --- Decision Variables ---
# z[i,t]: unit i ON (1) or OFF (0) at time t
model.z = pyo.Var(model.I_set, model.T_set, domain=pyo.Binary)
# y[i,t]: unit i STARTs UP (1) or not (0) at time t
model.y = pyo.Var(model.I_set, model.T_set, domain=pyo.Binary)
# x[i,t]: unit i SHUTs DOWN (1) or not (0) at time t (Auxiliary for clarity, but can be avoided)
model.x = pyo.Var(model.I_set, model.T_set, domain=pyo.Binary) # Can be derived, but useful for min down time formulation
# g[i,t]: power generated by unit i at time t (MW)
model.g = pyo.Var(model.I_set, model.T_set, domain=pyo.NonNegativeReals)

# --- Objective Function ---
def total_cost_rule(m):
    startup_c = sum(m.Cost_Startup[i] * m.y[i,t] for i in m.I_set for t in m.T_set)
    noload_c = sum(m.Cost_NoLoad[i] * m.z[i,t] for i in m.I_set for t in m.T_set)
    gen_c = sum(m.Cost_Gen[i] * m.g[i,t] for i in m.I_set for t in m.T_set)
    return startup_c + noload_c + gen_c
model.TotalCost = pyo.Objective(rule=total_cost_rule, sense=pyo.minimize)

# --- Constraints ---

# 1. Generator ON/OFF Logic (Startup/Shutdown definitions)
model.StatusLogic = pyo.ConstraintList()
for i in model.I_set:
    for t in model.T_set:
        if t == 1:
            model.StatusLogic.add(model.z[i,t] - model.Initial_Status[i] == model.y[i,t] - model.x[i,t])
        else:
            model.StatusLogic.add(model.z[i,t] - model.z[i,t-1] == model.y[i,t] - model.x[i,t])
        model.StatusLogic.add(model.y[i,t] + model.x[i,t] <= 1)

# 2. Minimum Up Time
model.MinUpTimeConstraint = pyo.ConstraintList()
for i in model.I_set:
    if model.Initial_Status[i] == 1 and model.Initial_Time_On[i] < model.MinUpTime[i]:
        required_on_periods = model.MinUpTime[i] - model.Initial_Time_On[i]
        for t_init in range(1, min(T, required_on_periods) + 1):
            model.MinUpTimeConstraint.add(model.z[i, t_init] == 1)
            model.MinUpTimeConstraint.add(model.y[i, t_init] == 0)
            model.MinUpTimeConstraint.add(model.x[i, t_init] == 0)
    for t in model.T_set:
        for k in range(model.MinUpTime[i]):
            if t + k <= T:
                model.MinUpTimeConstraint.add(model.z[i, t + k] >= model.y[i, t])

# 3. Minimum Down Time
model.MinDownTimeConstraint = pyo.ConstraintList()
for i in model.I_set:
    if model.Initial_Status[i] == 0 and model.Initial_Time_Off[i] < model.MinDownTime[i]:
        required_off_periods = model.MinDownTime[i] - model.Initial_Time_Off[i]
        for t_init in range(1, min(T, required_off_periods) + 1):
            model.MinDownTimeConstraint.add(model.z[i, t_init] == 0)
            model.MinDownTimeConstraint.add(model.y[i, t_init] == 0)
            model.MinDownTimeConstraint.add(model.x[i, t_init] == 0)
    for t in model.T_set:
        for k in range(model.MinDownTime[i]):
            if t + k <= T:
                model.MinDownTimeConstraint.add(model.z[i, t + k] <= 1 - model.x[i, t])

# 4. Generation Limits
model.GenerationLimits = pyo.ConstraintList()
for i in model.I_set:
    for t in model.T_set:
        model.GenerationLimits.add(model.g[i,t] >= model.Pmin[i] * model.z[i,t])
        model.GenerationLimits.add(model.g[i,t] <= model.Pmax[i] * model.z[i,t])

# 5. Demand Balance
model.DemandBalance = pyo.ConstraintList()
for t in model.T_set:
    model.DemandBalance.add(sum(model.g[i,t] for i in model.I_set) >= model.Demand[t])


# --- Solve the Model using Gurobi ---
solver = pyo.SolverFactory('gurobi')

# Optional: Set Gurobi-specific solver options
# solver.options['MIPGap'] = 0.01  # e.g., stop when the gap is 1%
# solver.options['TimeLimit'] = 300 # e.g., stop after 300 seconds
# solver.options['Threads'] = 0     # e.g., use all available threads (0 is default for Gurobi)
# solver.options['LogFile'] = "gurobi_uc.log" # To write Gurobi's log to a file

results = solver.solve(model, tee=True) # tee=True shows solver output in the console

# --- Display Results ---
if (results.solver.status == pyo.SolverStatus.ok) and \
   (results.solver.termination_condition == pyo.TerminationCondition.optimal):
    print("\n--- Optimal Solution Found (using Gurobi) ---")
    print(f"Total Cost: ${model.TotalCost():.2f}")

    print("\nUnit Status (z[i,t]):")
    print("Gen | " + " | ".join(f"T{t:<2}" for t in model.T_set))
    print("----|" + "-------" * T)
    for i in model.I_set:
        print(f"{i:<3} | " + " | ".join(f"{pyo.value(model.z[i,t]):<2.0f}" for t in model.T_set))

    print("\nUnit Startup (y[i,t]):")
    print("Gen | " + " | ".join(f"T{t:<2}" for t in model.T_set))
    print("----|" + "-------" * T)
    for i in model.I_set:
        print(f"{i:<3} | " + " | ".join(f"{pyo.value(model.y[i,t]):<2.0f}" for t in model.T_set))

    print("\nUnit Shutdown (x[i,t]):")
    print("Gen | " + " | ".join(f"T{t:<2}" for t in model.T_set))
    print("----|" + "-------" * T)
    for i in model.I_set:
        print(f"{i:<3} | " + " | ".join(f"{pyo.value(model.x[i,t]):<2.0f}" for t in model.T_set))

    print("\nGeneration Levels (g[i,t]) (MW):")
    print("Gen | " + " | ".join(f"  T{t:<4}" for t in model.T_set))
    print("----|" + "----------" * T)
    for i in model.I_set:
        print(f"{i:<3} | " + " | ".join(f"{pyo.value(model.g[i,t]):<6.1f}" for t in model.T_set))

    print("\nTotal Generation vs Demand (MW):")
    print("Time| Tot Gen | Demand  | Slack")
    print("----|---------|---------|---------")
    for t in model.T_set:
        total_gen_t = sum(pyo.value(model.g[i,t]) for i in model.I_set)
        demand_t = model.Demand[t]
        print(f"T{t:<2} | {total_gen_t:>7.1f} | {demand_t:>7.1f} | {(total_gen_t - demand_t):>7.1f}")

elif results.solver.termination_condition == pyo.TerminationCondition.infeasible:
    print("\n--- Model is Infeasible (using Gurobi) ---")
    print("Consider checking constraints, especially MinUp/MinDown initial conditions or demand levels.")
    # You can also try writing the model to an LP file to debug with Gurobi's tools:
    # model.write("infeasible_uc_model.lp", io_options={'symbolic_solver_labels': True})
    # print("LP file 'infeasible_uc_model.lp' written for debugging.")
else:
    print("\n--- Solver Status (Gurobi) ---")
    print("Status:", results.solver.status)
    print("Termination Condition:", results.solver.termination_condition)
    if hasattr(results.solver, 'message') and results.solver.message:
        print("Solver Message:", results.solver.message)

# For debugging the model structure:
# model.pprint()